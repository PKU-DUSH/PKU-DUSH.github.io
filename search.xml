<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++基础</title>
    <url>/C++%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<div class="note warning"><h1 id="C-知识"><a href="#C-知识" class="headerlink" title="C++知识"></a>C++知识</h1><h2 id="C-内存基础"><a href="#C-内存基础" class="headerlink" title="C++内存基础"></a>C++内存基础</h2><h3 id="进程虚拟空间地址划分"><a href="#进程虚拟空间地址划分" class="headerlink" title="进程虚拟空间地址划分"></a>进程虚拟空间地址划分</h3><img src="https://s2.loli.net/2023/10/07/oV6nFMAJB5rpih2.png" alt="image-20231007213657680" style="zoom:50%;" />

<p><img src="https://s2.loli.net/2023/10/07/GtWVpPKcloYHOT6.png" alt="image-20231007212931110"></p>
<ul>
<li>指令在运行的时候存放在在.text段；数据放在.data和.bbs段<ul>
<li>.data：存放已经初始化的数据且数据不为0</li>
<li>.bbs：存放未初始化的数据（系统会赋值为0，所以打印未初始化的数据会输出为0）</li>
</ul>
</li>
<li>程序内局部变量都是指令；全局变量和静态变量都是数据</li>
<li>指令存放在.text段，而指令执行的时候会在栈上开辟空间</li>
</ul>
<img src="https://s2.loli.net/2023/10/07/feUsTCEPRav6V8j.png" alt="image-20231007213056216" style="zoom: 67%;" />



<ul>
<li>对于不同的线程，用户空间是隔离的，内核空间是共享的</li>
<li>管道通信实际上是在内核空间划分了内存，所以才能通信，因为用户空间是隔离的</li>
</ul>
<h3 id="从编译器角度理解C-代码的编译和链接原理"><a href="#从编译器角度理解C-代码的编译和链接原理" class="headerlink" title="从编译器角度理解C++代码的编译和链接原理"></a>从编译器角度理解C++代码的编译和链接原理</h3><ul>
<li>编译过程如下：</li>
</ul>
<p><img src="https://s2.loli.net/2023/10/23/7QoHJPys9A1L3mG.png" alt="image-20231023223509832"></p>
<ul>
<li><p>编译生成的.o文件组成</p>
<ul>
<li>这里的每一行称为段<img src="https://s2.loli.net/2023/10/23/rcIURvgo6GnLS9X.png" alt="image-20231023221321923" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>编译中的符号表<br><img src="https://s2.loli.net/2023/10/23/6AUndlEhVjrNX5f.png" alt="image-20231023220927089"></p>
<p><img src="https://s2.loli.net/2023/10/23/BZCtUo89REv7gTw.png" alt="image-20231023221039508"></p>
<p><img src="https://s2.loli.net/2023/10/24/74OUCkfGo18MTEt.png" alt="image-20231023220457249"></p>
<ul>
<li>其中会标出 数据和指令存放的位置（.text和data），而引用的暂时标记为UND(可以出现很多UND，但是在代码中只能定义一次，要不就是重定义了)</li>
<li>g：global  l：local，链接的时候只能链接global的符号</li>
<li>编译过程中不分配地址，前面的地址都是0；但是指令在编译阶段就已经产生了，</li>
</ul>
</li>
<li><p>链接 </p>
<p><img src="https://s2.loli.net/2023/10/23/1nHxDJ9pz2LmRMS.png" alt="image-20231023223528196"></p>
<ul>
<li>第一步：合并编译后的.o文件的相同段（所以可执行文件也是一段一段的），并分配虚拟地址</li>
<li>符号重定向：符号解析成功后分配虚拟地址，把虚拟地址写回指令中叫符号重定向（因为编译后不分配地址，地址都为0）</li>
</ul>
</li>
<li><p>可执行文件</p>
<ul>
<li><p>和.o文件一样都是由段组成的，但是多了progrma heads，用于指明把哪些内容加载到内存<br><img src="https://s2.loli.net/2023/10/23/QDbs4n5KO9tzLvM.png" alt="image-20231023235152854"></p>
</li>
<li><p>此时.o文件在磁盘上，并有了虚拟地址，之后就是操作系统虚拟地址到物理地址的转换了</p>
<p><img src="https://s2.loli.net/2023/10/23/EmSwrzRiOl4tgkJ.png" alt="image-20231023235539410"></p>
</li>
</ul>
</li>
</ul>
<h2 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h2><h3 id="C-的new和delete"><a href="#C-的new和delete" class="headerlink" title="C++的new和delete"></a>C++的new和delete</h3><img src="https://s2.loli.net/2023/10/25/TfyCK9qI6RAm8Xh.png" alt="image-20231025230340531" style="zoom:50%;" />

<ul>
<li><p>new和malloc的两个区别</p>
<img src="https://s2.loli.net/2023/10/25/enyimbTpE4hkaqt.png" alt="image-20231025230147364" style="zoom:50%;" />

<img src="https://s2.loli.net/2023/10/25/GNBWLMVSnjqYtCU.png" alt="image-20231025225738550" style="zoom:50%;" />
</li>
<li><p>delete和free的区别</p>
<ul>
<li>无论是开辟数组还是单个元素 都是free(p)</li>
<li>而单个元素 delete p；数组 delete[] p；</li>
</ul>
</li>
<li><p>new有多少种？</p>
<ul>
<li>定位new 是把data赋值为50，也就是在指定的内存上填充值</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2023/10/25/eUh5FfR89mpi4rs.png" alt="image-20231025230745636" style="zoom:50%;" />

<h3 id="C-的const、指针和引用"><a href="#C-的const、指针和引用" class="headerlink" title="C++的const、指针和引用"></a>C++的const、指针和引用</h3><p><img src="https://s2.loli.net/2023/11/27/M6KNyRHigUoYZJz.png" alt="image-20231127140228238"></p>
<h4 id="C-和C中的const区别"><a href="#C-和C中的const区别" class="headerlink" title="C++和C中的const区别"></a>C++和C中的const区别</h4><blockquote>
<ul>
<li>C中的const并不是完全意义上的常量，只是在语法上规定了a不能作为左值再次赋值，实际上还是变量，因为可以用指针修改,所以也不能初始化中定义数组的长度(打印出来的值全是30)</li>
</ul>
<img src="https://s2.loli.net/2024/02/20/3T2AHCZYBFWSmr7.png" alt="image-20240220224830692" style="zoom:50%;" />
</blockquote>
<blockquote>
<ul>
<li>C++中必须初始化，但是是所有出现const的地方直接用20代替。所以*p&#x3D;30确实改变了a内存的值，但是*（&amp;a）是直接变成了*（&amp;20）,所以输出还是20</li>
</ul>
<img src="https://s2.loli.net/2023/11/27/RGJ1EtpNlXWFI8Z.png" alt="image-20231127141913977" style="zoom:50%;" />

<ul>
<li>假如用一个变量初始化（变量的值只有运行的时候才知道），可以运行，但是就退化成常变量了，和C中一模一样了</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/27/on8CBeTxfqAiKjD.png" alt="image-20231127142209072"></p>
</blockquote>
<h4 id="const和一二级指针的结合应用"><a href="#const和一二级指针的结合应用" class="headerlink" title="const和一二级指针的结合应用"></a>const和一二级指针的结合应用</h4><h5 id="const和一级指针的结合"><a href="#const和一级指针的结合" class="headerlink" title="const和一级指针的结合"></a>const和一级指针的结合</h5><blockquote>
<p>const修饰的量常出现的错误是：</p>
<ol>
<li>常量不能再作为左値＜&#x3D;这样会直接修改常量的値</li>
<li>不能把常量的地址泄露给一个普通的指针或者普通的引用变量&lt; &#x3D; 这样会间接修改常量的值，所以必须<code>const int *p = &amp;a</code></li>
</ol>
</blockquote>
<blockquote>
<p>const 和一级指针结合：</p>
<ul>
<li>const 修饰离它最近的类型，可以把const和离它最近的类型去掉，剩下的部分不能改变了；<ul>
<li>或者可以认为const修饰最大范围内能修改的变量：</li>
<li>比如<code>const int*p</code> ，*p被完全包含，所以不能变；<code>int *const p</code>,只有p被包含，所以p不能变。</li>
</ul>
</li>
</ul>
<ol>
<li><code>const int *p  = &amp;a</code>：可以改变p的值，不能改变*p的值，也就是可以改变地址，不能改变地址对应的值</li>
<li><code>int const* p </code>:和上面的一样！因为*和int不一样，不能单独定义变量，所以const修饰的还是int</li>
<li><code>int *const p</code>: 修饰的是·<code>int*</code>，所以不可以改变p的值，可以改变*p的值，也就是不可以改变地址，可以改变地址对应的值</li>
<li><code>const int *const p = &amp;a</code>：最严格的指针，地址和值都不能改变，第一个const修饰int不能改变*p，第二个const修饰<code>int*</code>不能改变p。<img src="https://s2.loli.net/2024/02/21/wo9nrC7pAzOEQmc.png" alt="image-20240221015833692" style="zoom:50%;" /></li>
</ol>
<ul>
<li>类型转换总结：</li>
</ul>
<img src="https://s2.loli.net/2024/02/21/RzS2gkBxcJQMXK6.png" alt="image-20240221020924985" style="zoom:50%;" />
</blockquote>
<blockquote>
<ul>
<li><strong>注意</strong>这两个输出都是 <code>int *</code>类型的，const后面没有指针就可以忽略</li>
</ul>
<img src="https://s2.loli.net/2024/02/21/et2cmL7kogDra9y.png" alt="image-20240221020656659" style="zoom:50%;" />


</blockquote>
<h5 id="const和二级指针的结合"><a href="#const和二级指针的结合" class="headerlink" title="const和二级指针的结合"></a>const和二级指针的结合</h5><blockquote>
<ul>
<li>q的值是一级指针的地址；*q的值等于p的值等于a的地址；**q的值等于*p的于a的值</li>
<li>a的类型是int，&amp;a的类型就是int*</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/qvcdCjH1SLiuY25.png" alt="image-20240229133342582" style="zoom:50%;" />

<ul>
<li><p>注意二级指针const无论在左面还是右面都不行</p>
<blockquote>
<img src="https://s2.loli.net/2024/02/29/pSjB4XzvefPbt7o.png" alt="image-20240229134544957" style="zoom:50%;" />

<ul>
<li>这个是不行的，二级指针const无论在左面还是右面都不行</li>
<li>因为<code>const int **q</code>表示a是一个常量无法被修改，而右面的<code>int *p</code>没有const说明可以通过p来修改a，这样就冲突了（<strong>这个想法是错误的</strong>）</li>
<li><strong>正确想法</strong>：***q的类型是const int <strong>*，说明可以进行<code>const int b = 20 ; \*q = &amp;b</code>,两边都是const int *类型。**但是</strong>*q和p都等于a的地址，p不是一个const，那么这就说明把一个const类型的地址放到了一个不是const类型的地址中，错误</li>
<li>也就是*q这块地址有两个名字，一个是<code>*q</code>,一个是<code>p</code>，第一个名字是const类型，第二个不是const类型的，所以不能把const类型的地址放到这块内存，必须两个名字都为const类型才可以。 <blockquote>
 <img src="https://s2.loli.net/2024/02/29/Ant8mf6EgI7RyHY.png" alt="image-20240229140713506" style="zoom: 50%;" /></blockquote>
</li>
<li>所以没有什么多级指针，只有一级指针，<code>const int **q 代表 const int*  *q </code>,前面的都是类型，代表这个指针（*q）类型是个地址，而int *q，代表指针（*q）是个int的数。</li>
<li>也就是二级指针的重点是有两个名字代表了同一个地址，对这块地址的操作就要小心</li>
</ul>
</blockquote>
</li>
<li><p>第三部分注意const修饰的是*，那么两面同时不看前面的int*,发现和第一部分是一样的</p>
</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/TPsgXcQVtnwvRNJ.png" alt="image-20240229134051396" style="zoom:50%;" />
</blockquote>
<h4 id="C-的左值引用和右值引用"><a href="#C-的左值引用和右值引用" class="headerlink" title="C++的左值引用和右值引用"></a>C++的左值引用和右值引用</h4><img src="https://s2.loli.net/2024/02/29/Uypi9IPHfALN26B.png" alt="image-20240229143443953" style="zoom:50%;" />

<p><img src="https://s2.loli.net/2024/02/29/zlj532TEPVYIuFJ.png" alt="image-20240229144721747"></p>
<blockquote>
<ul>
<li><p>指针和引用在汇编层无论是定义还是赋值都没有任何区别</p>
<blockquote>
<img src="https://s2.loli.net/2024/02/29/sEZ4L6VBXUfSlO9.png" alt="image-20240229142855285" style="zoom:50%;" />
</blockquote>
</li>
<li><p>所以不能int&amp;b &#x3D; 20；必须先定义a，然后int&amp;b&#x3D;a；因为20的地址是取不到的。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>结果是20 4 20 ，可以认为引用就是别名</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/1kSc3NFrTJzOQn6.png" alt="image-20240229143719754" style="zoom:50%;" />
</blockquote>
<blockquote>
<p>右值引用</p>
<ul>
<li><strong>不能</strong>int&amp;b &#x3D; 20；必须先定义a，然后int&amp;b&#x3D;a；因为20的地址是取不到的</li>
<li>但是<strong>可以</strong>int &amp;&amp; c &#x3D; 20； 汇编层面是给一个 临时地址，然后再放到c中</li>
<li>int &amp;&amp; c &#x3D; 20和 const int &amp; c &#x3D; 20 在汇编层面是<strong>一模一样</strong>的</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/rlSeZEq3oOakgD1.png" alt="image-20240229144323833" style="zoom: 33%;" />
</blockquote>
<h4 id="const、指针和引用的结合使用"><a href="#const、指针和引用的结合使用" class="headerlink" title="const、指针和引用的结合使用"></a>const、指针和引用的结合使用</h4><blockquote>
<img src="https://s2.loli.net/2024/02/29/2OQlKph6znaIeAw.png" alt="image-20240229150520761" style="zoom:33%;" />

<ul>
<li><p>注意要强制类型转换才能转成地址</p>
</li>
<li><p>注意const的位置，不能放在*前面；和<code>int *&amp;&amp;p</code>是一样的</p>
</li>
<li><p><code>const int *&amp;q = p</code>可以还原成<code>const int **q = &amp;p</code>就和前面的例子一样了</p>
</li>
<li><p>所以有引用的时候让你判断对错，换成指针比较好看一点</p>
</li>
</ul>
</blockquote>
<h3 id="inline内联函数和形参带默认值的函数"><a href="#inline内联函数和形参带默认值的函数" class="headerlink" title="inline内联函数和形参带默认值的函数"></a>inline内联函数和形参带默认值的函数</h3><h4 id="形参带默认值的函数"><a href="#形参带默认值的函数" class="headerlink" title="形参带默认值的函数"></a>形参带默认值的函数</h4><blockquote>
<ul>
<li>对于函数和函数的参数编译器是从上到下，从右往左执行，所以要形参的默认值要从右往左给；并且调用的时候是从左往右赋值的，那么也说明形参要从右往左给默认值(但是编译器压栈还是从右向左)</li>
<li>调用的时候直接给立即数比给变量效率高，因为编译层面上少了一次移动，直接压栈</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/fNmAP4hqeQivWw8.png" alt="image-20240229154807539" style="zoom: 33%;" />
</blockquote>
<h4 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h4><blockquote>
<ul>
<li>为什么要内联函数？因为调用函数的时候有参数压栈、函数栈帧开辟的一系列开销，当函数的内容很简单比如x+y的时候，调用函数开销远大于内容计算的开销，所以就要用inline</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/n9ar4YCFco2UdpM.png" alt="image-20240229155656500" style="zoom:33%;" />
</blockquote>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><blockquote>
<ul>
<li>C不能实现；只有C++能实现<ul>
<li>因为C在编译产生符号的时候只有函数名；而C++是函数名+参数列表</li>
<li>所以问能不能重载要考虑产生符号是否相同的问题，比如只有返回值不同就不能算重载，因为产生符号是相同的</li>
</ul>
</li>
<li>在同一个作用域才可以重载，比如都在全局作用域。如果定义到了局部作用域，那么会就近调用这一个函数，重载失效</li>
<li>const int 和int 不能重载，编译器都看作是int</li>
<li>函数重载属于静态多态，因为函数是在编译期间就要选择指定的；动态多态指的是运行期间调用</li>
<li></li>
</ul>
<img src="https://s2.loli.net/2024/02/29/pROSuc2TGwtgMN7.png" alt="image-20240229161154379" style="zoom:33%;" />
</blockquote>
<blockquote>
<ul>
<li>C和C++的互相调用</li>
<li>注意都是在C++里做的，只有C++能识别 extern</li>
</ul>
</blockquote>
<blockquote>
<img src="https://s2.loli.net/2024/02/29/ohakEL3i8KB9A4p.png" alt="image-20240229162158805" style="zoom:33%;" />

<ul>
<li>C++调用C，同样要扩C++的函数体</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/ras7WqFh3bxeGgl.png" alt="image-20240229162329645" style="zoom:33%;" />

<ul>
<li>这样写保证无论是C还是C++编译器，最后都可以被C文件调用<img src="https://s2.loli.net/2024/02/29/OfAh9ulHn1tU2ML.png" style="zoom:33%;" /></li>
</ul>
</blockquote>
<h3 id="类和对象、this指针"><a href="#类和对象、this指针" class="headerlink" title="类和对象、this指针"></a>类和对象、this指针</h3><blockquote>
<img src="https://s2.loli.net/2024/02/29/1mLjR25EXC6IoOT.png" alt="image-20240229164034883" style="zoom:33%;" />
</blockquote>
<blockquote>
<ul>
<li>注意有指针要➕const，防止改变私有成员变量</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/c8RBgFCl7JvOLz6.png" alt="image-20240229164212813" style="zoom:33%;" />
</blockquote>
<blockquote>
<ul>
<li>类中的函数会自动看成inline函数；而类外定义的函数必须手动inline，才会看成是内联函数</li>
<li>传递字符串的时候，常量指针必须定义为const，编译器防止解引用修改</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/tjXwOc8BRuHJI5G.png" alt="image-20240229164656964" style="zoom:33%;" />
</blockquote>
<blockquote>
<ul>
<li>算类占用的空间，只看成员变量就行，和成员函数无关</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/kj6Px9vIpu82oHU.png" alt="image-20240229165135559" style="zoom:33%;" />
</blockquote>
<blockquote>
<ul>
<li>既然成员函数只有一套，那怎么知道处理那个对象呢？</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/qvKMYl4N1HsS3zk.png" alt="image-20240229165554736" style="zoom:33%;" />

<img src="https://s2.loli.net/2024/02/29/yMHSkPj1iRrce2A.png" alt="image-20240229165625046" style="zoom:33%;" />
</blockquote>
<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><blockquote>
<ul>
<li>名字都和类名一样</li>
</ul>
<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240229223603950.png" alt="image-20240229223603950" style="zoom: 33%;" />

<ul>
<li>构造和析构避免了自己定义init和release需要自己用对象调用的问题</li>
<li>最后在return的时候从栈中析构（也就是先构造的后析构，后构造的先析构）</li>
<li>构造函数是在堆上开辟一个内存，定义对象是在栈上开辟内存<ul>
<li>所以定义对象的占用的空间：对象的大小（也就是成员变量的大小，记得字节对齐）+构造函数在堆上开辟的大小</li>
</ul>
</li>
<li>构造参数可以重载，析构只能有一个</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/S73U628QDNHBmps.png" alt="image-20240229221915795" style="zoom:50%;" />

<ul>
<li>不要自己调用析构函数，因为会把对象的内存delete，这时候对象就没了，不能再操作了</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/Km2kB5eWzFlC6aQ.png" alt="image-20240229222353374" style="zoom:50%;" />
</blockquote>
<blockquote>
<ul>
<li>内存无非有三块数据，堆和栈</li>
<li>SeqStack s：是开辟在栈上，并且通过<code>.</code>访问</li>
<li>SeqStack *ps是开辟在堆上，并且通过<code>-&gt;</code>访问</li>
<li>这跟leetcode链表对象的初始化是一样的！</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/q5L8vzRTjisNXSA.png" alt="image-20240229222547445" style="zoom:50%;" />

<ul>
<li>注意在堆上必须要手动delete，delete包含了调用对象的析构函数和释放指针两个作用</li>
</ul>
<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240229223022333.png" alt="image-20240229223022333" style="zoom:50%;" />
</blockquote>
<blockquote>
<ul>
<li>数据段的对象程序启动时构造，结束时析构（全局的对象）</li>
<li>栈上的对象定义的时候自动构造，return的时候自动析构。（<code>SeqStack s</code>）</li>
<li>堆上的对象（<code>SeqStack *ps</code>），new的时候自动调用构造函数，必须手动delete才能自动调用析构函数</li>
</ul>
<p><img src="https://s2.loli.net/2024/02/29/IR4lXgoQYte8FSq.png" alt="image-20240229224426929"></p>
</blockquote>
<h3 id="对象的深拷贝和浅拷贝"><a href="#对象的深拷贝和浅拷贝" class="headerlink" title="对象的深拷贝和浅拷贝"></a>对象的深拷贝和浅拷贝</h3><blockquote>
<ul>
<li>如果自己不定义构造&#x2F;析构&#x2F;拷贝函数，程序会默认提供空参数的 这三种函数</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/sczf2lASYh4aoXO.png" alt="image-20240229225333526" style="zoom:50%;" />
</blockquote>
<blockquote>
<ul>
<li>浅拷贝（系统默认给你的拷贝构造函数）：拷贝同一块内存</li>
<li>浅拷贝函数指向的是同一块内存，所以上图的代码不能正确运行，因为结束的时候要析构同一块内存两次</li>
</ul>
<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240229225756407.png" alt="image-20240229225756407" style="zoom: 33%;" />

<ul>
<li>类中对数据的拷贝一般用for循环，而不能用memcpy直接复制，因为这做的也是浅拷贝，如果放的不是int而是指针，那么复制完会出现和上面一样的问题。</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/EbNRyj4O5hMvBxd.png" alt="image-20240229230431988" style="zoom:33%;" />

<ul>
<li>所以浅拷贝是否有问题主要看这个对象有没有占用（指向）外部资源，如果只是一个int，那么不会有问题，但是如果指向外部的内存，那么在析构的时候就会有多次析构同一块内存的</li>
<li>问题了</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><p>深拷贝（自定义拷贝构造函数）</p>
</li>
<li><p>其实就是要自己在new开辟一块堆内存，就不会有浅拷贝的问题了</p>
<img src="https://s2.loli.net/2024/02/29/V2jMLlJksNqWeIu.png" alt="image-20240229230139166" style="zoom:33%;" /></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>自定义赋值函数</li>
<li>默认的赋值函数也是浅拷贝</li>
<li>s1，s2都定义后这样复制问题更大，因为此时s2指向的内存都丢了，并且指向了s1指向的的内存</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/yxowqf8jKACuHTM.png" alt="image-20240229230816585" style="zoom:33%;" />

<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240229230934226.png" alt="image-20240229230934226" style="zoom:33%;" />

<ul>
<li>这里要把 <code>=</code> 运算符重载，函数体内应该先把s2自己的内存delete，然后for循环复制数据（同时防止一下自己赋值给自己）</li>
</ul>
<img src="https://s2.loli.net/2024/02/29/SQntjmr4zRyALlD.png" alt="image-20240229231432705" style="zoom:33%;" />
</blockquote>
<h3 id="类和对象实践"><a href="#类和对象实践" class="headerlink" title="类和对象实践"></a>类和对象实践</h3><blockquote>
<ul>
<li>构造函数遇见指针的时候，要考虑<ul>
<li>自身成员变量要先new开辟内存</li>
<li>外部传来的指针是否为空？</li>
<li>如果为空不要设为nullptr，因为这样后面所有的成员函数都要判断是否为空，设为一个0字符，那么后面的就不需要判断自己的成员变量是否为0了。</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2024/03/16/k36Sfb4rzO8lMjX.png" alt="image-20240316184553432" style="zoom: 33%;" />

<ul>
<li>注意第二部分第一个不是赋值重载，因为赋值重载是对象已经被定义完成之后的操作。这个是对象在构造过程中的操作，所以是调用拷贝构造函数。</li>
<li>这三部分中的语句都是等价的</li>
</ul>
<img src="https://s2.loli.net/2024/03/16/i98s3jSDZR7HUXr.png" alt="image-20240316191103098" style="zoom: 50%;" />
</blockquote>
<blockquote>
<ul>
<li>循环队列类的实现</li>
</ul>
<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240316192433846.png" alt="image-20240316192433846" style="zoom:50%;" />

<img src="https://s2.loli.net/2024/03/16/HNQKDd3l48qstbu.png" alt="image-20240316192529220" style="zoom:50%;" />

<img src="https://s2.loli.net/2024/03/16/6JxvmkRzwyUBXE7.png" alt="image-20240316192632300" style="zoom:50%;" />

<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240316192738101.png" alt="image-20240316192738101" style="zoom:50%;" />

<ul>
<li>拷贝构造和赋值构造</li>
</ul>
<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240316192814563.png" alt="image-20240316192814563" style="zoom:50%;" />

<img src="https://s2.loli.net/2024/03/16/EQ7d9Akix6gzKfs.png" alt="image-20240316192905064" style="zoom:50%;" />

<img src="https://s2.loli.net/2024/03/16/AGmeikwOWzVZNpn.png" alt="image-20240316192934949" style="zoom: 67%;" />

  
</blockquote>
<h3 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h3><blockquote>
<img src="https://s2.loli.net/2024/03/16/pRNzbJoPLQUGZh6.png" alt="image-20240316193453153" style="zoom:50%;" />

<ul>
<li>成员对象</li>
</ul>
<img src="https://s2.loli.net/2024/03/16/lsMJEawLejz4nRK.png" alt="image-20240316193521223" style="zoom:50%;" />

<img src="https://s2.loli.net/2024/03/16/EIwckTyj1KulfxV.png" alt="image-20240316193548022" style="zoom:50%;" />

<ul>
<li>当成员变量中有别的类的对象的时候，那么在构造函数中也要初始化构造成员对象</li>
</ul>
<img src="https://s2.loli.net/2024/03/16/ZUG6tnxNcTyYzBa.png" alt="image-20240316194031556" style="zoom:50%;" />

<ul>
<li>不要在构造函数体里这样做，因为这个时候用的是赋值构造函数，而对象_data还没构造出来呢，所以会出错</li>
</ul>
<img src="https://s2.loli.net/2024/03/16/iwrdDj9ubCxHh57.png" alt="image-20240316195441730"  />

<ul>
<li>注意这里ma是无效值，<strong>初始化列表的顺序 和成员变量定义的顺序相同</strong></li>
</ul>
<p><img src="https://s2.loli.net/2024/03/16/7PmAV1N4JbBIGpi.png" alt="**image-20240316201815267**"></p>
</blockquote>
<h3 id="类的各种成员方法和区别"><a href="#类的各种成员方法和区别" class="headerlink" title="类的各种成员方法和区别"></a>类的各种成员方法和区别</h3><p><img src="https://s2.loli.net/2024/03/16/Zb2lcp8CiUVNwAJ.png" alt="image-20240316232051127"></p>
<blockquote>
<ul>
<li>比如统计类所有对象的数量，可以定义一个静态变量。也可以定义全局变量，但是就不是面向对象了</li>
<li>属于类级别，所以不占用内存</li>
</ul>
<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240316230047107.png" alt="image-20240316230047107" style="zoom:50%;" />

<ul>
<li>可以同时创建一个静态成员方法，这样就不用通过对象来调用函数，而是直接用类调用函数；访问所有对象共享的信息</li>
</ul>
<img src="https://s2.loli.net/2024/03/16/mGZDRAs46UQ9SfI.png" alt="image-20240316230812395" style="zoom: 67%;" />

<ul>
<li>本质区别在于普通方法产生this指针，而静态成员方法没有this指针</li>
<li>静态方法只能访问静态成员变量，不能访问普通成员变量；因为没有this指针，不知道调用哪一个对象</li>
</ul>
<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240316230455050.png" alt="image-20240316230455050" style="zoom:50%;" />


</blockquote>
<blockquote>
<ul>
<li>创建一个常对象，那么调用普通成员方法会有问题。因为调用函数实际上是传递一个this对象指针，但是常对象的指针是const*；不能吧一个const指针传递给普通的指针（一级指针的基础知识）；不能把const *实参传递给*的形参</li>
</ul>
<img src="https://s2.loli.net/2024/03/16/dcx9Ke5pY4WrJIR.png" alt="image-20240316230956692" style="zoom:67%;" />

<ul>
<li>解决办法很简单，把想要调用的成员也变成const类型；注意const位置，在函数（）最后</li>
<li>只读的都实现成常成员方法，这样无论传过来的实参是否是const都能用</li>
<li>常成员方法不能修改变量，因为是 const *this指针，所以*this就不能改变了(也就是this指向的值不能变)；而实际上函数体里每一个变量的读写都省略了<code> this-&gt;price</code></li>
</ul>
<img src="https://s2.loli.net/2024/03/16/UkHoD6qab1ug7AS.png" alt="image-20240316231637874" style="zoom:67%;" />
</blockquote>
<h3 id="指向类成员（成员变量-方法）的指针"><a href="#指向类成员（成员变量-方法）的指针" class="headerlink" title="指向类成员（成员变量&#x2F;方法）的指针"></a>指向类成员（成员变量&#x2F;方法）的指针</h3><blockquote>
<ol>
<li>定义指针要加上类的作用域</li>
<li>调用指针，要通过具体的对象调用</li>
</ol>
<ul>
<li>静态成员变量&#x2F;方法除外，可以看做全局变量&#x2F;方法，只不过落在了类的作用域中</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>指向成员变量的指针</li>
<li>定义一个指针用于指向成员变量一定要加作用域，否则不知道是哪里的成员变量，也就是要<code>Test::</code>限定</li>
<li>同时调用一定要通过具体的对象来调用</li>
</ul>
<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240316232839444.png" alt="image-20240316232839444" style="zoom:50%;" />

<ul>
<li>而静态成员变量不需要类作用域限定，因为静态成员变量是不依赖类的</li>
</ul>
<img src="https://s2.loli.net/2024/03/16/ZkiyqIDfQcoLP87.png" alt="image-20240316233030083" style="zoom:50%;" />
</blockquote>
<blockquote>
<ul>
<li><p>指向成员方法的指针</p>
</li>
<li><p>和上面一样，指向普通成员方法一定要依赖作用域</p>
</li>
<li><p>注意函数指针的定义方法</p>
<ul>
<li>定义是<code>void (*p)() = &amp;fun()</code></li>
<li>调用是<code>(*p)()</code></li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2024/03/16/D1M5yXchm7GHoep.png" alt="image-20240316233456216" style="zoom:50%;" />
</blockquote>
<h3 id="理解函数模板"><a href="#理解函数模板" class="headerlink" title="理解函数模板"></a>理解函数模板</h3><ul>
<li>模板目的：只关心代码的逻辑，而不关心具体的类型</li>
</ul>
<p><img src="https://s2.loli.net/2024/03/22/BdToeFLR6EyKUGk.png" alt="image-20240322231932580"></p>
<p><img src="https://s2.loli.net/2024/03/22/mvDf8sQrpIeClPJ.png" alt="image-20240322232133322"></p>
<blockquote>
<ul>
<li>模板函数</li>
</ul>
<img src="https://s2.loli.net/2024/03/22/iU41GYxtqVCg3dj.png" alt="image-20240322140855701" style="zoom: 33%;" />

<img src="https://s2.loli.net/2024/03/22/HbQF2XceD4xES8K.png" alt="image-20240322140946780" style="zoom:33%;" />

<ul>
<li>不写&lt;&gt;也可以通过传入参数的类型来推断出T的类型，但是参数的类型必须一致；最下面的就不行了</li>
</ul>
<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240322141218827.png" alt="image-20240322141218827" style="zoom:33%;" />

<ul>
<li>特例化模板</li>
</ul>
<img src="/Users/dush/Library/Application Support/typora-user-images/image-20240322222457966.png" alt="image-20240322222457966" style="zoom:33%;" />

<ul>
<li><p>模板不能放到其他CPP中调用，编译的时候会出错，因为只有被调用的时候才会被编译，声明的时候是不被编译的。所以要放在.h头文件中。</p>
<ul>
<li>除非在声明的时候就实例化（尽量别用，否则就失去了模板的目的了）</li>
</ul>
<p><img src="https://s2.loli.net/2024/03/22/XGDc6Uvoij1K2Z4.png" alt="image-20240322232226943"></p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>非类型参数（T叫类型参数）</li>
</ul>
<img src="https://s2.loli.net/2024/04/18/pfUOSQB2hwkDzco.png" alt="image-20240418233935307" style="zoom:50%;" />
</blockquote>
<h3 id="理解类模板"><a href="#理解类模板" class="headerlink" title="理解类模板"></a>理解类模板</h3><blockquote>
<img src="https://s2.loli.net/2024/04/18/qE1pjzcCM3erZSQ.png" alt="image-20240418235325942" style="zoom:50%;" />
</blockquote>
<blockquote>
</blockquote>
</div>
]]></content>
      <categories>
        <category>C++笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>HELLO</title>
    <url>/HELLO/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>BLOG</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/LeetCode/</url>
    <content><![CDATA[<div class="note info"><h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                    left  = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>二分查找<ul>
<li><strong>有序数组</strong>，<strong>无重复元素</strong></li>
<li>边界条件：<ul>
<li>target在[left，right]，也就是<code>right = num.size() - 1</code></li>
<li>于是 left&lt;&#x3D;right（等号的边界条件是最右面的数是target，也就是<code>right]</code> ）</li>
<li>于是 <code>if (nums[mid] &gt; target)    right = mid-1</code></li>
</ul>
</li>
</ul>
</li>
<li>为什么<code>int mid = left + (right - left)/2</code>  <ul>
<li><code>left &lt;= MAX_VALUE</code>和 <code>right &lt;= MAX_VALUE</code>是肯定的</li>
<li>但是<code>left+right &lt;= MAX_INT</code> 我们无法确定，所以会造成栈溢出。</li>
</ul>
</li>
</ul>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力解，双层for</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;size; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                size--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != val)</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>双指针法（快慢指针法）： <strong>一个快指针和慢指针可以在一个for循环下完成两个for循环的工作。</strong><ul>
<li>快指针：<strong>用于判断逻辑，寻找应该放入新数组的元素</strong> ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向新数组下标的位置</li>
<li>数组中的<strong>双指针</strong>其实就是<strong>下标索引</strong></li>
</ul>
</li>
</ul>
<h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            nums[i]=nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());<span class="comment">//注意sort的用法</span></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size() ,<span class="number">0</span>)</span></span>; <span class="comment">//注意vector的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j =nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt;= j;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]*nums[i] &gt;= nums[j]*nums[j]) &#123;</span><br><span class="line">                result[k--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[k--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>双指针法：</p>
<ul>
<li>由于数组有序，那么平方之后最大值肯定在两侧，所以可以两侧都设置一个指针</li>
<li>注意<code>i&lt;=j</code>，因为如果<code>i==j</code>就停止，那么i和j同时指向的这个元素就不会被放入新数组中</li>
<li>这个思想有点像快排？</li>
</ul>
</li>
<li><pre><code class="C++">if (nums[i]*nums[i] &gt; nums[j]*nums[j])
                result[k--] = nums[i++]*nums[i++];//注意不能这样，这样在第一个nums[i++]后i就会增加了		
            else																	//可以nums[i]*nums[i++]
                result[k--] = nums[j--]*nums[j--];	
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 长度最小的子数组</span><br><span class="line"></span><br><span class="line">&gt; 题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/description/</span><br><span class="line"></span><br><span class="line">~~~c++</span><br><span class="line">//暴力解</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = 100000; //注意length变化的情况下要设为全局变量，并且有更新的逻辑</span><br><span class="line">        int subLength = 0;       </span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            int result = 0;</span><br><span class="line">            for (int j = i; j &lt; nums.size(); j++ ) &#123;</span><br><span class="line">                result += nums[j];</span><br><span class="line">                if (result &gt;= target)&#123;</span><br><span class="line">                    subLength = j - i + 1;</span><br><span class="line">                    length = subLength &lt; length ? subLength : length; //用此方式可以更简洁</span><br><span class="line">                    break;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return length == 100000 ? 0 : length;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//滑动窗口</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = INT_MAX; //注意int最大值用INT_MAX表示比较好</span><br><span class="line">        int i = 0;</span><br><span class="line">        int subLength = 0;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int j = 0; j &lt; nums.size(); j++)&#123;</span><br><span class="line">            result += nums[j];</span><br><span class="line">            while (result &gt;= target) &#123;	//！！注意这里是while而不是if，可以考虑j到头了，if的话后面几个就没法再减小了</span><br><span class="line">                subLength = j - i + 1;</span><br><span class="line">                length = subLength &lt; length ? subLength : length;</span><br><span class="line">                result -= nums[i++]; //关键代码，等同于另一个for</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return length == INT_MAX ? 0 : length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>两重for循环的本质是：<strong>第一个for循环确定起始位置，另一个for循环确定结束位置</strong></p>
</li>
<li><p>滑动窗口（也是双指针法的一种）：</p>
<ul>
<li>不像双重for一样每次for都会更新result，而是<strong>只在一个for中计算一次result【即总在结束位置累加计算】，然后通过起始位置减少result</strong>。</li>
<li>在本题中实现滑动窗口，主要确定如下三点：<ul>
<li>窗口内是什么？<ul>
<li>窗口就是 <strong>满足其和 ≥ s 的长度最小的 连续 子数组</strong>。</li>
</ul>
</li>
<li>如何移动窗口的起始位置？<ul>
<li>窗口的起始位置如何移动：<strong>如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）</strong>。</li>
<li><code>result -= nums[i++]</code>  关键就是通过这句实现起始位置的移动</li>
</ul>
</li>
<li>如何移动窗口的结束位置？<ul>
<li>窗口的结束位置如何移动：<strong>窗口的结束位置就是遍历数组的指针，也就是for循环里的索引</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>思路（文字翻译成代码）：</p>
<ul>
<li><strong>判断条件是什么</strong>：和大于等于target  -&gt;  <strong>result</strong> &gt;&#x3D;target</li>
<li>长度最小的数组：<ul>
<li>判断长度最小需要循环比较然后在更新，所以要全局变量length</li>
<li>每个循环体要有局部变量用于比较是否最小  -&gt;  subLength</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">https://leetcode.cn/problems/spiral-matrix-ii/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">result</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">//注意vector二维数组的创建方式</span></span><br><span class="line">        <span class="type">int</span> loop = n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>,starty = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">//key:每一次循环都要比上次少一圈</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++)</span><br><span class="line">                result[startx][j] = count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset;i++)</span><br><span class="line">                result[i][j] = count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--)</span><br><span class="line">                result[i][j] = count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--)</span><br><span class="line">                result[i][j] = count++;</span><br><span class="line">            </span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            result[n/<span class="number">2</span>][n/<span class="number">2</span>] = count;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>思路：</p>
<ul>
<li>要绕几圈？n&#x2F;2圈，单纯的循环while更简洁</li>
<li>螺旋的要分四个for循环来，每一条边都要单独的for循环</li>
<li>每一圈的赋值的起始点和终止点都有变化<ul>
<li>起始点通过startx&#x2F;y++ 改变</li>
<li>终止点通过offset++改变</li>
</ul>
</li>
</ul>
</li>
<li><p>注意奇偶区别，奇数的时候中间的要特殊逻辑（loop &#x3D; n&#x2F;2 + 1不行，因为n为偶数比如4的时候就是循环两次） </p>
</li>
<li><p>注意offset是控制循环终止边界的，因为开始边界是由while循环的startx++决定的</p>
</li>
</ul>
</div>

<div class="note info"><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">https://leetcode.cn/problems/remove-linked-list-elements/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead -&gt; next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur -&gt; next)&#123;		<span class="comment">//注意都是cur -&gt; next</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt; next -&gt; val == val)&#123;		</span><br><span class="line">                ListNode* tmp = cur -&gt; next;</span><br><span class="line">                cur -&gt; next = cur -&gt; next -&gt;next;</span><br><span class="line">                <span class="keyword">delete</span>  tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        head = dummyHead -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ListNode *virtualNode  = new ListNode()</code> &#x2F;&#x2F;这样创建对象是创建一个指针指向开辟的内存，所以可以和NULL比较。</p>
<ul>
<li>但是记住用完要delete</li>
<li>在堆开辟，占用空间大，适合大程序；<code>ListNode virtualNode</code>栈开辟，占用空间小，适合小程序</li>
</ul>
</li>
<li><p>操作当前节点必须要找前一个节点才能操作，但是头结点没有前一个节点了，这就需要虚拟头节点了。</p>
</li>
<li><p>节点移除要设置tmp变量</p>
</li>
<li><p>是对<code>cur-&gt;next</code>判断的，否则定位不到前一个节点</p>
</li>
</ul>
<h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/design-linked-list/description/">https://leetcode.cn/problems/design-linked-list/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        <span class="keyword">return</span> cur -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addAtIndex</span>(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addAtIndex</span>(size, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        index = <span class="built_in">max</span>(<span class="number">0</span>, index);</span><br><span class="line">        size++;</span><br><span class="line">        ListNode* pred = dummyHead;</span><br><span class="line">        ListNode* Add = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(index--)  <span class="comment">//注意，链表中有索引都是通过while(index--)来遍历的</span></span><br><span class="line">            pred = pred -&gt; next;</span><br><span class="line">        Add -&gt; next = pred -&gt; next;</span><br><span class="line">        pred -&gt; next = Add;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        size--;</span><br><span class="line">        ListNode* del = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">            del = del -&gt; next;</span><br><span class="line">        ListNode* tmp = del -&gt; next;</span><br><span class="line">        del -&gt; next = del -&gt; next -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode* dummyHead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123; <span class="comment">//核心是两个指针</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* tmp = cur -&gt; next; <span class="comment">//注意tmp指针，若无tmp，一旦cur-&gt;next改变，将无法找到下个节点</span></span><br><span class="line">            cur -&gt; next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点*"></a>两两交换链表中的节点*</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">https://leetcode.cn/problems/swap-nodes-in-pairs/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead -&gt; next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur -&gt; next &amp;&amp; cur -&gt; next -&gt; next)&#123;  <span class="comment">//注意交换两个节点不仅要判断next，还要判断next-&gt;next</span></span><br><span class="line">            ListNode* tmp =  cur -&gt; next;   </span><br><span class="line">            ListNode* tmp1 = cur -&gt; next -&gt; next -&gt; next; <span class="comment">//保存断开指针后的值</span></span><br><span class="line"></span><br><span class="line">            cur -&gt; next = cur -&gt; next -&gt; next; <span class="comment">//步骤一</span></span><br><span class="line">            cur -&gt; next -&gt; next = tmp; <span class="comment">//步骤二</span></span><br><span class="line">            cur -&gt; next -&gt; next -&gt; next = tmp1; <span class="comment">//步骤三</span></span><br><span class="line"></span><br><span class="line">            cur = cur -&gt; next -&gt; next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead -&gt; next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>交换结点类的题都至少要设置三个指针<ul>
<li>两个指针用于交换</li>
<li>一个指针tmp用于存储临时节点</li>
</ul>
</li>
<li>设置一个虚拟头结点更方便<ul>
<li>注意dummyHead是个结点，不是指针！！！<ul>
<li>一般返回操作后的链表就用dummyHead-&gt;next返回</li>
</ul>
</li>
<li>而cur是个指针，指向这个dummyHead</li>
<li>所以cur可以改变dummyHead-&gt;next</li>
</ul>
</li>
</ul>
<h3 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* slow = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        dummyHead -&gt; next = head;</span><br><span class="line">        fast = dummyHead;</span><br><span class="line">        slow = dummyHead;</span><br><span class="line">        n++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">            fast = fast -&gt; next;</span><br><span class="line">        <span class="keyword">while</span> (fast)&#123;</span><br><span class="line">            fast = fast -&gt; next;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow -&gt; next = slow -&gt; next -&gt; next;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> dummyHead -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>典型的快慢指针问题</p>
<p><img src="https://s2.loli.net/2023/10/09/Oj3dnykKAEf41xa.png" alt="image-20231009124214423"></p>
</li>
</ul>
<h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交*"></a>链表相交*</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//传统双指针方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lengthA = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curA)&#123;</span><br><span class="line">            lengthA++;</span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB)&#123;</span><br><span class="line">            lengthB++;</span><br><span class="line">            curB = curB -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB; <span class="comment">//注意要将cur返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lengthB &gt; lengthA)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(lengthA, lengthB);</span><br><span class="line">            <span class="built_in">swap</span>(curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> distance = lengthA - lengthB;</span><br><span class="line">        <span class="keyword">while</span> (distance--)</span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curA &amp;&amp; curB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB)</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            curA = curA -&gt; next;</span><br><span class="line">            curB = curB -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数学公式方法*</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">            ListNode* curA = headA;</span><br><span class="line">            ListNode* curB = headB;</span><br><span class="line">            <span class="keyword">if</span> (!curA || !curB)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (curA != curB)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!curA)</span><br><span class="line">                    curA = headB;</span><br><span class="line">                curA = curA -&gt; next;  <span class="comment">//注意if和本行的顺序，如果换过来就是见到nullptr就跳过，这样在无交点时就会死循环</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!curB)</span><br><span class="line">                    curB = headA;</span><br><span class="line">                curB = curB -&gt; next;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// curA =    curA == nullptr ? headB : curA -&gt; next;</span></span><br><span class="line">                <span class="comment">// curB =    curB == nullptr ? headA : curB -&gt; next;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> curA;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>传统双指针：双指针先对齐，然后同时向后搜索</p>
<p><img src="https://s2.loli.net/2023/10/09/frjqdV6YMApWOBT.png" alt="image-20231009163406450"></p>
</li>
<li><p>数学公式双指针：两个指针都搜索a+b+c的距离，此时一定是节点的位置</p>
<ul>
<li>注意注释掉的部分解决了无交点无限循环的问题，因为如果没有交点，那么最后都要到达nullptr而跳出循环（两指针都遍历了A+B的长度）；也就是nullptr不能跳过而直接变成另一链表的头节点，这样在无交点的时候就没有终止条件了。</li>
</ul>
<p><img src="https://s2.loli.net/2023/10/09/UgPH4OQjkBvRroC.png" alt="image-20231009163005284"></p>
</li>
</ul>
<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表*"></a>环形链表*</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">https://leetcode.cn/problems/linked-list-cycle-ii/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next -&gt;next;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">                <span class="keyword">while</span> (cur != fast)&#123;</span><br><span class="line">                    cur = cur -&gt; next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>先快慢指针判断是否有环</p>
</li>
<li><p>有环情况下找到入口</p>
<ul>
<li>也就是<strong>从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>（虽然可能从相遇节点出发的指针已经绕了好几圈）<br><img src="https://s2.loli.net/2023/10/09/gV763BlhrF1pPsR.png" alt="image-20231009171140021"></li>
</ul>
</li>
<li><p>注意一旦有<code>fast -&gt;next -&gt;next</code>,那么不仅要判断<code>fast != NULL</code>， 也要判断 <code>fast -&gt;next != NULL</code>，因为空指针是不能-&gt;next的。</p>
</li>
</ul>
</div>

<div class="note info"><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><blockquote>
<p><strong>当需要查询一个元素是否出现过</strong>，或者<strong>一个元素是否在集合里的时候</strong>，要第一时间想到哈希法</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/10/12/6hCWI3deNvVcfzO.png" alt="image-20231012191805536"></p>
<ul>
<li>哈希表要考虑：元素是否可以重复 &amp; 元素是否有序<ul>
<li>若不需要有序：<ul>
<li>用unorder，因为此时查询和增删效率都最高</li>
</ul>
</li>
</ul>
</li>
<li><code>vector</code><ul>
<li>.begin()  .end()<ul>
<li>返回指针</li>
<li><code>vector&lt;int&gt;::iterator iter=a.begin(); cout&lt;&lt;*iter</code></li>
</ul>
</li>
<li>.front() .back()<ul>
<li>返回引用</li>
<li><code>vector&lt;int&gt;a={1,0}; cout&lt;&lt;a.back();</code></li>
</ul>
</li>
</ul>
</li>
<li>set是集合，map是键值对映射</li>
</ul>
<h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><blockquote>
<p> 题目链接：<a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++ )</span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>] ++;  <span class="comment">//注意s[i] - &#x27;a&#x27;就把字符转换成下标了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++ )</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span> ; i++ )</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意<code>record[s[i] - &#39;a&#39;]</code>，这样把字符转换成下标了</li>
</ul>
<h3 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">https://leetcode.cn/problems/intersection-of-two-arrays/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2)</span><br><span class="line">            <span class="keyword">if</span> (nums.<span class="built_in">find</span>(num) != nums.<span class="built_in">end</span>())  <span class="comment">//find()返回的是一个指针，如果没找到就指向最后一个元素，也就是end()</span></span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());  <span class="comment">//因为要求返回值是vector</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意find()的用法</li>
</ul>
<h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/happy-number/description/">https://leetcode.cn/problems/happy-number/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span> <span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; resSet;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="built_in">sum</span> (n);</span><br><span class="line">            n = res; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resSet.<span class="built_in">find</span>(res) != resSet.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                resSet.<span class="built_in">insert</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>自己定义的函数要放在solution函数外面</li>
<li>注意取每一位的方法</li>
<li><strong>无限循环怎么判断?</strong> <code>unordered_set</code>，看是否会出现重复数字</li>
</ul>
<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和*"></a>两数之和*</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++ )&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> &#123;i, iter -&gt; second&#125;;</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i));  </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>unordered_map查询效率O(1)，指的是由哈希表实现，等于直接查询下标<ul>
<li>所以想查询值的下标，不能用数组的思维用下标对应值，这样还是O(n)</li>
<li>而是把值作为下标（key），下标作为值（value）</li>
</ul>
</li>
<li>注意函数的返回值<ul>
<li>vector的返回值是一个数组，如果为空不能是return 0；而是<code>return{};</code></li>
<li>如果是数不能是 return 1，而是 <code>return {1};</code></li>
</ul>
</li>
</ul>
<h3 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加*"></a>四数相加*</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/4sum-ii/description/">https://leetcode.cn/problems/4sum-ii/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map12;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : nums1)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b : nums2)</span><br><span class="line">                map12[a + b]++;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d : nums4)&#123;</span><br><span class="line">                <span class="keyword">if</span> (map12.<span class="built_in">find</span>(<span class="number">0</span> - (c + d)) != map12.<span class="built_in">end</span>() )</span><br><span class="line">                    count+=map12[<span class="number">0</span> - (c + d)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>和上一道题的想法一模一样</li>
<li>注意不要超过两层循环，你想知道a+b就要用两层循环</li>
</ul>
<p><img src="https://s2.loli.net/2023/10/26/wZtygAxW3XI7oCE.png" alt="image-20231026125715364"></p>
<h3 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/ransom-note/description/">https://leetcode.cn/problems/ransom-note/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : magazine)</span><br><span class="line">            record[a - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> b : ransomNote)&#123; </span><br><span class="line">            record[b - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (record[b - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果数组可以做就别用map了，因为map的空间消耗比较大</li>
</ul>
<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和*"></a>三数之和*</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());    <span class="comment">//注意sort的使用方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] +nums[right] &gt; <span class="number">0</span>)</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] +nums[right] &lt; <span class="number">0</span>)</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i],nums[left],nums[right]&#125;);  <span class="comment">//注意二维vector的push_back，是&#123;&#125;</span></span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                        left++;</span><br><span class="line">                    </span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>还是一样，双指针可以在一个for循环下完成两个for循环的工作，那么这道暴力解是三重for的就可以通过双指针变成$O(n^2)$</p>
</li>
<li><p>注意去重操作</p>
</li>
<li><p>再看看思路：<a href="https://www.programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF">https://www.programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E6%80%9D%E8%B7%AF</a></p>
</li>
</ul>
<h3 id="四树之和"><a href="#四树之和" class="headerlink" title="四树之和"></a>四树之和</h3><blockquote>
<p>题目链接：<a href="https://leetcode.cn/problems/4sum/description/">https://leetcode.cn/problems/4sum/description/</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line"></span><br><span class="line">## 字符串</span><br><span class="line"></span><br><span class="line">### 反转字符串</span><br><span class="line"></span><br><span class="line">&gt; 题目链接：https:<span class="comment">//leetcode.cn/problems/reverse-string/description/</span></span><br><span class="line"></span><br><span class="line">~~~C++</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; (s.<span class="built_in">size</span>())/<span class="number">2</span>; i++ , j--)</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意和反转链表的区别，因为链表不能直接通过下标索引找到，而字符串可以，所以可以直接头尾交换</li>
</ul>
</div>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>LinkedList</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<div class="note warning"><h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="编译结果输出到文件"><a href="#编译结果输出到文件" class="headerlink" title="编译结果输出到文件"></a>编译结果输出到文件</h2><ul>
<li><p>针对中断产生的编译结果，可以输出到指定文件中以供分析</p>
<blockquote>
<p>tee : 输出结果的同时也保留终端输出</p>
<p>1：正确运行输出</p>
<p>2：错误运行输出</p>
</blockquote>
<ul>
<li><p><strong>输出正确运行和错误运行结果（即输出全部编译结果）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make 2&gt;&amp;1 | <span class="built_in">tee</span> out.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出正确运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make &gt; out.txt    OR   make 1&gt; out.txt   </span><br></pre></td></tr></table></figure>
</li>
<li><p>输出错误运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make 2&gt; out.txt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="后台不挂断地执行命令"><a href="#后台不挂断地执行命令" class="headerlink" title="后台不挂断地执行命令"></a>后台不挂断地执行命令</h2><blockquote>
<p>nohup : 不挂断地运行命令（没有后台运行的功能）<br>&amp; : 在后台运行，当用户退出（挂起）的时候，命令自动跟着结束</p>
<p>输出结果自动存放在nohup.out中</p>
<ul>
<li>注意使用该指令后要用exit退出终端，直接关闭可能会导致进程终止</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./Allwmake &amp;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>查看当前后台运行的进程</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">jobs</span> -l</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考链接：<a href="https://blog.csdn.net/qq_37555071/article/details/113781938">https://blog.csdn.net/qq_37555071/article/details/113781938</a></p>
</blockquote>
<h2 id="一些系统命令"><a href="#一些系统命令" class="headerlink" title="一些系统命令"></a>一些系统命令</h2><ul>
<li>查找进程并kill</li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -aux  //显示所有程序</span><br><span class="line">ps -ef | grep 进程关键字  //查找指定进程</span><br><span class="line"><span class="built_in">kill</span> -9 进程号PID    //kill进程</span><br></pre></td></tr></table></figure>



<ul>
<li>查看CPU占用等信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top    //查看CPU占用，<span class="built_in">shift</span>+m 按内存占用排序</span><br></pre></td></tr></table></figure>

<ul>
<li>查看进程运行时间<ul>
<li>ps -eo lstart 启动时间</li>
<li>ps -eo etime 运行多长时间.</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -eo pid,lstart,etime | grep 2459398</span><br><span class="line">//2459398 Fri Dec  8 01:26:12 2023  5-15:30:10</span><br></pre></td></tr></table></figure>

<ul>
<li>解压命令</li>
</ul>
<blockquote>
<ol>
<li>*.tar 用 tar –xvf 解压</li>
<li><em>.tar.gz和</em>.tgz 用 tar –xzf 解压</li>
<li>*.zip 用 unzip 解压</li>
</ol>
</blockquote>
<blockquote>
<p>压缩命令：<code>tar -zcvf /home/dush/OpenFOAM/dush-10/swak4Foam.tar.gz swak4Foam </code></p>
</blockquote>
<ul>
<li>查看cpu核数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo</span><br><span class="line">lscpu</span><br></pre></td></tr></table></figure>

<ul>
<li>查看最大可用线程数(CPU逻辑核心)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nproc</span></span><br><span class="line">//make -j $(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>





<h2 id="sh文件Permission-denied的解决办法"><a href="#sh文件Permission-denied的解决办法" class="headerlink" title=".sh文件Permission denied的解决办法"></a>.sh文件Permission denied的解决办法</h2><blockquote>
<p>赋予全部权限777（rwx）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 xxx.sh</span><br></pre></td></tr></table></figure>



<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul>
<li>移动文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//如果需要复制，把<span class="built_in">mv</span>改为<span class="built_in">cp</span></span><br><span class="line">//改文件名aaa-&gt;bbb</span><br><span class="line"><span class="built_in">mv</span> aaa bbb</span><br><span class="line"></span><br><span class="line">//移动文件或文件夹</span><br><span class="line"><span class="built_in">mv</span> 文件（夹）名 目的路径</span><br><span class="line"></span><br><span class="line">//移动 info 目录到 logs 目录中。注意，如果 logs 目录不存在，则该命令将 info 改名为 logs</span><br><span class="line"><span class="built_in">mv</span> info/ logs </span><br><span class="line"></span><br><span class="line">//移动 info 目录下所有目录和文件到 logs 目录中</span><br><span class="line"><span class="built_in">mv</span> info/* logs </span><br></pre></td></tr></table></figure>

<ul>
<li>查看文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//在终端显示文件所有内容</span><br><span class="line"><span class="built_in">cat</span> file.txt</span><br><span class="line"></span><br><span class="line">//按页查看文件内容，适合查看大文件</span><br><span class="line">//按空格翻页，按q退出</span><br><span class="line">less file.txt</span><br><span class="line">less -N file.txt  //添加行号	</span><br></pre></td></tr></table></figure>

<ul>
<li>删除文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span>[选项] 文件或目录</span><br><span class="line">选项：</span><br><span class="line">-f：强制删除（force），和 -i 选项相反，使用 -f，系统将不再询问，而是直接删除目标文件或目录。</span><br><span class="line">-i：和 -f 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 -i 可以有效防止不小心删除有用的文件或目录。</span><br><span class="line">-r：递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</span><br><span class="line">//删除目录是 <span class="built_in">rm</span> -r， 但是会一直提示，所以<span class="built_in">rm</span> -rf</span><br><span class="line">//虽然 <span class="string">&quot;-rf&quot;</span> 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 <span class="string">&quot;rm -rf&quot;</span> 选项</span><br></pre></td></tr></table></figure>

<h2 id="在没有root权限的情况下编译软件显示Permission-denied问题"><a href="#在没有root权限的情况下编译软件显示Permission-denied问题" class="headerlink" title="在没有root权限的情况下编译软件显示Permission denied问题"></a>在没有root权限的情况下编译软件显示Permission denied问题</h2><blockquote>
<p>没有root权限是无法写入&#x2F;usr&#x2F;local&#x2F;bin&#x2F;文件中的</p>
</blockquote>
<p>解决办法：</p>
<ol>
<li>自定义编译的输出目录，比如<code>./configure --prefix=/home/dush/re2c </code></li>
<li>把命令添加到环境变量中<ul>
<li>打开～&#x2F;.bashrc or ~&#x2F;.zshrc</li>
<li>在末尾加入<code>export PATH=$PATH:/home/dush/re2c/bin</code> 即可</li>
</ul>
</li>
</ol>
<ul>
<li>或者直接把可执行文件加入到环境变量，例如：<code>export PATH=$PATH:/home/dush/tree-2.1.1</code></li>
</ul>
<blockquote>
<p>可以看考这个链接：<a href="https://blog.csdn.net/qq_41705840/article/details/124900211">https://blog.csdn.net/qq_41705840/article/details/124900211</a></p>
</blockquote>
<h2 id="终端SCP上传-下载文件"><a href="#终端SCP上传-下载文件" class="headerlink" title="终端SCP上传&#x2F;下载文件"></a>终端SCP上传&#x2F;下载文件</h2><blockquote>
<p>若下载目录则 scp -r</p>
</blockquote>
<ul>
<li>从工作站上下载文件到本地</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp username@servername:/path/filename /Users/mac/path</span><br></pre></td></tr></table></figure>

<ul>
<li>从本地上传文件到工作站</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /path/filename username@servername:/path</span><br></pre></td></tr></table></figure>




</div>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>BASH</tag>
      </tags>
  </entry>
  <entry>
    <title>远程工作站安装OpenFOAM</title>
    <url>/OpenFOAM%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<div class="note default"><h1 id="远程工作站安装OpenFOAM教程"><a href="#远程工作站安装OpenFOAM教程" class="headerlink" title="远程工作站安装OpenFOAM教程"></a>远程工作站安装OpenFOAM教程</h1><blockquote>
<p>一般来说，Linux下安装OpenFOAM有两种方法：</p>
<p>一种是直接用apt下载，但是此种方法仅限于个人电脑（因为需要sudo权限）；</p>
<p>另外一种更为推荐的常用办法是用<strong>源代码编译安装</strong>，由于需要远程连接实验室的电脑，在实验室的Linux环境下安装，所以也只能用这个办法。</p>
</blockquote>
<blockquote>
<p>推荐直接根据官方教程来，注意是Source Pack：<a href="https://openfoam.org/download/11-source/">https://openfoam.org/download/11-source/</a></p>
</blockquote>
<h2 id="下载并解压源文件"><a href="#下载并解压源文件" class="headerlink" title="下载并解压源文件"></a>下载并解压源文件</h2><h3 id="step1-：-建立OpenFOAM文件夹"><a href="#step1-：-建立OpenFOAM文件夹" class="headerlink" title="step1 ： 建立OpenFOAM文件夹"></a>step1 ： 建立OpenFOAM文件夹</h3><p><img src="https://s2.loli.net/2023/09/24/xBYPZWgMnkvzK4r.png" alt="image-20230924144932715"></p>
<h3 id="step2-：执行下载解压命令"><a href="#step2-：执行下载解压命令" class="headerlink" title="step2 ：执行下载解压命令"></a>step2 ：执行下载解压命令</h3><p><img src="https://s2.loli.net/2023/09/24/7oLWQOd95IB1bME.png" alt="image-20230924150351555"></p>
<p><img src="https://s2.loli.net/2023/09/24/fXPTIvrAEUWm7nG.png" alt="image-20230924150504744"></p>
<h3 id="step3-：改文件名，便于以后使用"><a href="#step3-：改文件名，便于以后使用" class="headerlink" title="step3 ：改文件名，便于以后使用"></a>step3 ：改文件名，便于以后使用</h3><p><img src="https://s2.loli.net/2023/09/24/amTJlYC87QdWSAP.png" alt="image-20230924150737127"></p>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><blockquote>
<p>注意是在~&#x2F;.bashrc中设置</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/09/24/LKj5nD4fk3z1eXV.png" alt="image-20230924152124605"></p>
<p><img src="https://s2.loli.net/2023/09/24/5jQ1pDItLcUZVdS.png" alt="image-20230924152114681"></p>
<blockquote>
<p>最后运行一下bashrc脚本</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/09/24/1iLYepaK732XVBw.png" alt="image-20230924152235522"></p>
<h2 id="下载编译第三方库（包括paraview）"><a href="#下载编译第三方库（包括paraview）" class="headerlink" title="下载编译第三方库（包括paraview）"></a>下载编译第三方库（包括paraview）</h2><h3 id="Installing-Scotch-PT-Scotch"><a href="#Installing-Scotch-PT-Scotch" class="headerlink" title="Installing Scotch&#x2F;PT-Scotch"></a>Installing Scotch&#x2F;PT-Scotch</h3><p><img src="https://s2.loli.net/2023/09/24/6TENoFiHRfj97Y2.png" alt="image-20230924154149151"></p>
<h3 id="Installing-ParaView"><a href="#Installing-ParaView" class="headerlink" title="Installing ParaView"></a>Installing ParaView</h3><p><img src="https://s2.loli.net/2023/09/24/ldoEZeqDvt6PAHu.png" alt="image-20230924154308317"></p>
<blockquote>
<ul>
<li>这里出问题了，但是不用管，可以用<strong>paraFoam -builtin</strong>代替</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/24/cEt6iRV1BNHpf9m.png" alt="image-20230924155942595"></p>
</blockquote>
<h2 id="编译OpenFOAM"><a href="#编译OpenFOAM" class="headerlink" title="编译OpenFOAM"></a>编译OpenFOAM</h2><p><img src="https://s2.loli.net/2023/09/24/vuVrpsQejiHLNtI.png" alt="image-20230924160049450"></p>
<h2 id="运行简单算例并可视化"><a href="#运行简单算例并可视化" class="headerlink" title="运行简单算例并可视化"></a>运行简单算例并可视化</h2><h3 id="创建运行文件夹"><a href="#创建运行文件夹" class="headerlink" title="创建运行文件夹"></a>创建运行文件夹</h3><p><img src="https://s2.loli.net/2023/09/24/WD2LAREJhTSl5aO.png" alt="image-20230924160932211"></p>
<h3 id="运行简单算例"><a href="#运行简单算例" class="headerlink" title="运行简单算例"></a>运行简单算例</h3><p><img src="https://s2.loli.net/2023/09/25/ugl7SPyibWa9vI3.png" alt="image-20230925212038629"></p>
<ul>
<li>成功运行</li>
</ul>
<p>​	<img src="https://s2.loli.net/2023/09/25/MPivyQYuLrEoksH.png" alt="image-20230925212121916"></p>
</div>
]]></content>
      <categories>
        <category>vsfFOAM</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OpenFOAM</tag>
      </tags>
  </entry>
  <entry>
    <title>ParaView使用</title>
    <url>/ParaView%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<div class="note warning"><h1 id="ParaView使用"><a href="#ParaView使用" class="headerlink" title="ParaView使用"></a>ParaView使用</h1><h2 id="本地ParaView查看远程工作站文件"><a href="#本地ParaView查看远程工作站文件" class="headerlink" title="本地ParaView查看远程工作站文件"></a>本地ParaView查看远程工作站文件</h2><ol>
<li><p>首先在远程终端输入<code>pvserver</code><br> <img src="https://s2.loli.net/2023/10/08/qIGsmbXt6exFWQ5.png" alt="image-20231007191801789"></p>
</li>
<li><p>在本地ParaView中 File-&gt;connect  进行配置</p>
<ul>
<li>Server Type 选择Client&#x2F;Server</li>
<li>Host输入工作站IP</li>
<li>port默认即可</li>
</ul>
</li>
<li><p>双击刚创建好的Server即可连接到远程机器，直接打开远程文件</p>
</li>
</ol>
<blockquote>
<ul>
<li>注意如果没有foam文件，手动创建一个run.foam的空文件，然后用ParaView打开此空文件即可</li>
<li>此后连接过程中，有可能出现提示框等待60s，且一直不消失导致卡住，个人解决办法是删掉并重新配置step 2<ul>
<li>update：梯子关了就好了</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="ParaView的基本使用"><a href="#ParaView的基本使用" class="headerlink" title="ParaView的基本使用"></a>ParaView的基本使用</h2><blockquote>
<p>官方教程：<a href="https://docs.paraview.org/en/latest/UsersGuide/index.html">https://docs.paraview.org/en/latest/UsersGuide/index.html</a></p>
</blockquote>
<ol>
<li><p>切片、切块</p>
<ul>
<li>Slice&#x2F;Clip，Properties中的Nomal调整方向（法向量）</li>
</ul>
<p><img src="https://s2.loli.net/2023/10/08/6FD8X1lZduhaMcQ.png" alt="image-20231008154400595"></p>
</li>
<li><p>显示外部、框架、内部</p>
<p><img src="https://s2.loli.net/2023/10/08/8WhQRTYdKNI4qt3.png" alt="image-20231008155015532"></p>
<ul>
<li><p>外部：Surface&#x2F;Surface with edges&#x2F;Wireframe&#x2F;Feature Edges</p>
</li>
<li><p>内部：Volume（需要渲染，有点慢）</p>
</li>
</ul>
</li>
<li><p>画等值面</p>
<ul>
<li><p>contour -&gt;  properties -&gt; Value Range中设置参数（代表的就是值为该参数的等值面）</p>
<p><img src="https://s2.loli.net/2023/10/08/3NyAhnGTLHjrzfx.png" alt="image-20231008160013396"></p>
<p><img src="https://s2.loli.net/2023/10/08/7iuy14xfdB8Q65C.png" alt="image-20231008165533308"></p>
</li>
</ul>
</li>
<li><p>设置阈值（高于某值的一律设为最大值，低于某值则设为最小值）</p>
<ul>
<li><p>Lower&#x2F;Higher Threshold</p>
<p><img src="https://s2.loli.net/2023/10/08/V7lciHktSv6nJj3.png" alt="image-20231008160619201"></p>
</li>
</ul>
</li>
</ol>
<h2 id="后处理计算涡量"><a href="#后处理计算涡量" class="headerlink" title="后处理计算涡量"></a>后处理计算涡量</h2><img src="https://s2.loli.net/2024/06/26/RNmVj6Bw3XE8dnu.png" alt="image-20240626153115437" style="zoom:50%;" />

<p><code>(GradientU_1 - GradientU_5) (GradientU_4 - GradientU_7)( GradientU_8 - GradientU_3)</code></p>
</div>]]></content>
      <categories>
        <category>vsfFOAM</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OpenFOAM</tag>
        <tag>vsfFOAM</tag>
      </tags>
  </entry>
  <entry>
    <title>git&amp;github</title>
    <url>/git-github/</url>
    <content><![CDATA[<div class="note warning"><h2 id="git-merge-pull-request"><a href="#git-merge-pull-request" class="headerlink" title="git merge&#x2F;pull request"></a>git merge&#x2F;pull request</h2><img src="https://s2.loli.net/2023/11/22/Qfo34dlcw5W1NBH.png" alt="image-20231122205333317" style="zoom:50%;" />

<img src="https://s2.loli.net/2023/11/22/Rfg36EaTvnxbLIs.png" alt="image-20231122201538592" style="zoom:50%;" />

<div class="note info"><ul>
<li><code>git status</code> # 查看当前状态</li>
<li><code>git log</code> # 查看操作记录</li>
<li><code>git branch</code>  # 显示所有本地分支</li>
<li><code>git branch -d dev</code> # 删除分支</li>
</ul>
</div>

<blockquote>
<ol>
<li><code>git clone</code></li>
<li><code>git checkout -b dev</code> # 创建并切换至“dev”分支</li>
<li><code>git add . </code> <strong># 将目录中所有文件添加到暂存区中</strong></li>
<li><code>git commit -m &quot;xxx&quot;</code>  <strong># 把暂存区中的文件提交到本地仓库中并添加描述信息</strong></li>
<li><code>git checkout master</code> # 切换到master分支</li>
<li><code>git merge dev</code> # 把dev分支合并到当前master分支</li>
<li><code>git push -u origin master</code>  # <strong>将本地仓库的分支提交至相应的远程仓库分支</strong><ul>
<li>第一次使用 <code>git push -u origin master</code> 之后，下次可以直接使用 <code>git pull</code> 拉取代码，就不需要输入完整的命令 <code>git pull origin master </code>来拉取代码了。第二次也可以用<code> git push</code>推送代码而不用<code>git push origin master</code>。</li>
<li>一般情况下(多人合作)，本地修改代码后，每次从本地仓库merge到远程仓库之前都要先进行git pull（会自动和本地提交合并，与本地有冲突时需要手动合并，所以要commit之后再pull否则会覆盖修改的代码）操作，保证push到远程仓库时没有版本冲突。</li>
</ul>
</li>
</ol>
<ul>
<li><pre><code class="bash">git clone
cd
git checkout -b dev
git add . &amp;&amp; git commit -m &quot;test-dev&quot;
    
<p>#如果推送到远程的dev就直接git push origin dev<br>git checkout master<br>git merge dev<br>git push origin master<br></code></pre></p>
</li>
</ul>
</blockquote>
<blockquote>
<p>tips:</p>
<ul>
<li><code>git clone</code>包括了<code>git init</code>（本地创建文件git remote origin关联远程仓库才之前需要git init）</li>
<li>以上是合作者的操作方式，如果不是，那么需要先fork成为自己的github仓库 -&gt; git clone到本地修改 -&gt; 推送到自己的github上之后再PR</li>
<li>git merge 冲突问题解决方案：<a href="https://blog.csdn.net/qq_42780289/article/details/97945300">https://blog.csdn.net/qq_42780289/article/details/97945300</a></li>
</ul>
</blockquote>
<h2 id="终端git超时问题"><a href="#终端git超时问题" class="headerlink" title="终端git超时问题"></a>终端git超时问题</h2><blockquote>
<p>fatal: unable to connect to github.com:<br>github.com[0: 20.205.243.166]: errno&#x3D;Connection timed out</p>
</blockquote>
<ul>
<li>把<code>git clone git://github.com/ninja-build/ninja.git</code>中的<code>git</code>改成<code>https</code>就好了</li>
</ul></div>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>远程工作站安装vsfFOAM</title>
    <url>/%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C%E7%AB%99%E5%AE%89%E8%A3%85vsfFOAM/</url>
    <content><![CDATA[<div class="note warning"><h1 id="vsfFOAM安装"><a href="#vsfFOAM安装" class="headerlink" title="vsfFOAM安装"></a>vsfFOAM安装</h1><blockquote>
<p>将vsfFOAM文件夹直接从PC拖入远程工作站的OpenFOAM文件夹内 后出现问题：</p>
<p><img src="https://s2.loli.net/2023/09/25/yZEikHJnRmPYtld.png" alt="image-20230925150025410"></p>
<ol>
<li><p>尝试用chmod +x 赋予权限，但还是有问题</p>
<p><img src="https://s2.loli.net/2023/09/25/DvkcgOIPx4TeKZM.png" alt="image-20230925175133908"></p>
<p><img src="https://s2.loli.net/2023/09/25/kDRBigzvoxHuwTM.png" alt="image-20230925175048192"></p>
</li>
</ol>
<ul>
<li>此问题已解决：OpenFOAM11删除了fvCFD这个头文件，所以推荐vsfFOAM依赖OpenFOAM10使用</li>
</ul>
</blockquote>
<h2 id="加载OpenFOAM-10环境"><a href="#加载OpenFOAM-10环境" class="headerlink" title="加载OpenFOAM-10环境"></a>加载OpenFOAM-10环境</h2><p><img src="https://s2.loli.net/2023/09/25/SQVFKahm4q2oz7y.png" alt="image-20230925212347606"></p>
<h2 id="编译vsfFOAM"><a href="#编译vsfFOAM" class="headerlink" title="编译vsfFOAM"></a>编译vsfFOAM</h2><blockquote>
<ul>
<li><p>注意vsfFOAM位置</p>
<p><img src="https://s2.loli.net/2023/09/25/LqjcFlIgV514Xfr.png" alt="image-20230925212448048"></p>
</li>
</ul>
</blockquote>
<ul>
<li>编译</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/25/UbuOm6LDZtjV4aR.png" alt="image-20230925212525526"></p>
<h2 id="运行教学算例"><a href="#运行教学算例" class="headerlink" title="运行教学算例"></a>运行教学算例</h2><blockquote>
<ul>
<li>出现如下问题，原因是文件路径不符合，解决办法可以直接复制泰勒格林流文件夹里的文件到run文件夹下</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/25/9A8DWP2NLqugSsj.png" alt="image-20230925213619260"></p>
<ul>
<li>加一个&#x2F;*即可<br><img src="https://s2.loli.net/2023/09/28/i6aDyVtUph5qsxj.png" alt="image-20230925214436191"><br><img src="https://s2.loli.net/2023/09/28/kFrYa4JtUlgXhMC.png" alt="image-20230925214542805"></li>
</ul>
</blockquote>
<h3 id="构造网格"><a href="#构造网格" class="headerlink" title="构造网格"></a>构造网格</h3><p><img src="https://s2.loli.net/2023/09/25/7E5HTYBZpct4agk.png" alt="image-20230925214712144"></p>
<h3 id="初始化流场"><a href="#初始化流场" class="headerlink" title="初始化流场"></a>初始化流场</h3><blockquote>
<ul>
<li><p>出现命令找不到的问题，因为vsfFOAM依赖于OpenFOAM，所以实际上是在OpenFOAM中找不到这个命令（如下二图）</p>
<ul>
<li>OpenFOAM中只有setFields能够设置简单的初始场，funkyxxx需要自行安装。</li>
</ul>
<p><img src="https://s2.loli.net/2023/09/25/jbh2nK7aX3uwits.png" alt="image-20230925220552066"></p>
<p><img src="https://s2.loli.net/2023/09/25/3y9saYoefGlKpLR.png" alt="image-20230925220653957"></p>
</li>
</ul>
</blockquote>
<h4 id="安装funkySetFields"><a href="#安装funkySetFields" class="headerlink" title="安装funkySetFields"></a>安装funkySetFields</h4><blockquote>
<ul>
<li>可以根据这篇博客以及官方教程来<ul>
<li><a href="https://blog.csdn.net/zq93538196/article/details/118310086">https://blog.csdn.net/zq93538196/article/details/118310086</a></li>
<li><a href="https://openfoamwiki.net/index.php/Installation/swak4Foam">https://openfoamwiki.net/index.php/Installation/swak4Foam</a></li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2023/09/25/1komGpsQ4POtUZ3.png" alt="image-20230925235839051"></p>
<h3 id="分解计算域"><a href="#分解计算域" class="headerlink" title="分解计算域"></a>分解计算域</h3><p><img src="https://s2.loli.net/2023/09/25/krHLUtGSWz8nc1D.png" alt="image-20230925235906887"></p>
<h3 id="执行运算-重组计算域"><a href="#执行运算-重组计算域" class="headerlink" title="执行运算&amp;重组计算域"></a>执行运算&amp;重组计算域</h3><ul>
<li><p>并行执行运算使用如下指令<img src="https://s2.loli.net/2023/09/28/Yv4L1iqtkpI92F8.png" alt="image-20230928153233799"></p>
<ul>
<li>并非使用UserGuide中的vsfFoam指令。</li>
</ul>
</li>
<li><p>重组计算域使用如下指令：<img src="https://s2.loli.net/2023/09/28/KOk8RscVuMtHgiW.png" alt="image-20230928153400874"></p>
</li>
</ul>
<blockquote>
<p>此过程可能会耗费数个小时，建议使用nohup 和&amp; 指令，避免中途退出。</p>
<ul>
<li><p>最后产生的nohup.out文件大概有9w行数据（如下）：</p>
<p><img src="https://s2.loli.net/2023/09/28/v1fKCHA7Z5RDeTO.png" alt="image-20230928153832170"></p>
</li>
</ul>
</blockquote>
<h3 id="paraFoam-builtin后处理"><a href="#paraFoam-builtin后处理" class="headerlink" title="paraFoam -builtin后处理"></a>paraFoam -builtin后处理</h3><p><img src="https://s2.loli.net/2023/09/27/vR2LHDcAF9mib6p.png" alt="image-20230927213541886"></p>
<p><img src="https://s2.loli.net/2023/09/27/IFOfxmJ2jiysdGY.png" alt="image-20230927213631892"></p>
<h1 id="vsfFOAM编程相关"><a href="#vsfFOAM编程相关" class="headerlink" title="vsfFOAM编程相关"></a>vsfFOAM编程相关</h1><ul>
<li>引入OpenFOAM中的.H文件的时候要在Make-options中一并设置<ul>
<li>有时会出现在OpenFOAM中，该.H文件引用的某一.H文件无法找到，但是OpenFOAM中确实存在，那么先find -name “xxx”找到该文件的位置，也在Make-options中链接</li>
</ul>
</li>
</ul>
</div>
]]></content>
      <categories>
        <category>vsfFOAM</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OpenFOAM</tag>
        <tag>vsfFOAM</tag>
      </tags>
  </entry>
</search>
